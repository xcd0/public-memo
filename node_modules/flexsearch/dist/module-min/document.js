import{IndexOptions,DocumentOptions,DocumentDescriptor,FieldOptions,StoreOptions,EncoderOptions}from"./type.js";import StorageInterface from"./db/interface.js";import Index from"./index.js";import WorkerIndex from"./worker.js";import Encoder,{fallback_encoder}from"./encoder.js";import Cache,{searchCache}from"./cache.js";import{is_string,is_object,parse_simple}from"./common.js";import apply_async from"./async.js";import{exportDocument,importDocument}from"./serialize.js";import{KeystoreMap,KeystoreSet}from"./keystore.js";import"./document/add.js";import"./document/search.js";import Charset from"./charset.js";export default function Document(a){if(!this||this.constructor!==Document)return new Document(a);const b=a.document||a.doc||a;let c,d;if(this.tree=[],this.field=[],this.marker=[],this.key=(c=b.key||b.id)&&parse_tree(c,this.marker)||"id",d=a.keystore||0,d&&(this.keystore=d),this.fastupdate=!!a.fastupdate,this.reg=!this.fastupdate||a.worker||a.db?d&&!0?new KeystoreSet(d):new Set:d&&!0?new KeystoreMap(d):new Map,this.storetree=(c=b.store||null)&&c&&!0!==c&&[],this.store=c?d&&!0?new KeystoreMap(d):new Map:null,this.cache=(c=a.cache||null)&&new Cache(c),a.cache=!1,this.worker=a.worker||!1,this.priority=a.priority||4,this.index=parse_descriptor.call(this,a,b),(this.tag=null,(c=b.tag)&&("string"==typeof c&&(c=[c]),c.length))){this.tag=new Map,this.tagtree=[],this.tagfield=[];for(let a,b,d=0;d<c.length;d++){if(a=c[d],b=a.field||a,!b)throw new Error("The tag field from the document descriptor is undefined.");a.custom?this.tagtree[d]=a.custom:(this.tagtree[d]=parse_tree(b,this.marker),a.filter&&("string"==typeof this.tagtree[d]&&(this.tagtree[d]=new String(this.tagtree[d])),this.tagtree[d]._filter=a.filter)),this.tagfield[d]=b,this.tag.set(b,new Map)}}if(this.worker){this.fastupdate=!1;const a=[];for(const b of this.index.values())b.then&&a.push(b);if(a.length){const b=this;return Promise.all(a).then(function(a){let c=0;for(const d of b.index.entries()){const e=d[0];let f=d[1];f.then&&(f=a[c],b.index.set(e,f),c++)}return b})}}else a.db&&(this.fastupdate=!1,this.mount(a.db))}Document.prototype.mount=function(a){let b=this.field;if(this.tag)for(let a,c=0;c<this.tagfield.length;c++){a=this.tagfield[c];let d;this.index.set(a,d=new Index({},this.reg)),b===this.field&&(b=b.slice(0)),b.push(a),d.tag=this.tag.get(a)}const c=[],d={db:a.db,type:a.type,fastupdate:a.fastupdate};for(let e,f,g=0;g<b.length;g++){d.field=f=b[g],e=this.index.get(f);const h=new a.constructor(a.id,d);h.id=a.id,c[g]=h.mount(e),e.document=!0,g?e.bypass=!0:e.store=this.store}const e=this;return this.db=Promise.all(c).then(function(){e.db=!0})},Document.prototype.commit=async function(){const a=[];for(const b of this.index.values())a.push(b.commit());await Promise.all(a),this.reg.clear()},Document.prototype.destroy=function(){const a=[];for(const b of this.index.values())a.push(b.destroy());return Promise.all(a)};function parse_descriptor(a,b){const c=new Map;let d=b.index||b.field||b;is_string(d)&&(d=[d]);for(let e,f,g=0;g<d.length;g++){if(e=d[g],is_string(e)||(f=e,e=e.field),f=is_object(f)?Object.assign({},a,f):a,this.worker){let a;a=f.encoder,a=a&&a.encode?a:new Encoder("string"==typeof a?Charset[a]:a||{});const b=new WorkerIndex(f,a);b?c.set(e,b):this.worker=!1}this.worker||c.set(e,new Index(f,this.reg)),f.custom?this.tree[g]=f.custom:(this.tree[g]=parse_tree(e,this.marker),f.filter&&("string"==typeof this.tree[g]&&(this.tree[g]=new String(this.tree[g])),this.tree[g]._filter=f.filter)),this.field[g]=e}if(this.storetree){let a=b.store;is_string(a)&&(a=[a]);for(let b,c,d=0;d<a.length;d++)b=a[d],c=b.field||b,b.custom?(this.storetree[d]=b.custom,b.custom._field=c):(this.storetree[d]=parse_tree(c,this.marker),b.filter&&("string"==typeof this.storetree[d]&&(this.storetree[d]=new String(this.storetree[d])),this.storetree[d]._filter=b.filter))}return c}function parse_tree(a,b){const c=a.split(":");let d=0;for(let e=0;e<c.length;e++)a=c[e],"]"===a[a.length-1]&&(a=a.substring(0,a.length-2),a&&(b[d]=!0)),a&&(c[d++]=a);return d<c.length&&(c.length=d),1<d?c:c[0]}Document.prototype.append=function(a,b){return this.add(a,b,!0)},Document.prototype.update=function(a,b){return this.remove(a).add(a,b)},Document.prototype.remove=function(a){is_object(a)&&(a=parse_simple(a,this.key));for(const b of this.index.values())b.remove(a,!0);if(this.reg.has(a)){if(this.tag&&!this.fastupdate)for(let b of this.tag.values())for(let c of b){const d=c[0],e=c[1],f=e.indexOf(a);-1<f&&(1<e.length?e.splice(f,1):b.delete(d))}this.store&&this.store.delete(a),this.reg.delete(a)}return this.cache&&this.cache.remove(a),this},Document.prototype.clear=function(){const a=[];for(const b of this.index.values()){const c=b.clear();c.then&&a.push(c)}if(this.tag)for(const a of this.tag.values())a.clear();return this.store&&this.store.clear(),this.cache&&this.cache.clear(),a.length?Promise.all(a):this},Document.prototype.contain=function(a){return this.db?this.index.get(this.field[0]).db.has(a):this.reg.has(a)},Document.prototype.cleanup=function(){for(const a of this.index.values())a.cleanup();return this},Document.prototype.get=function(a){return this.db?this.index.get(this.field[0]).db.enrich(a).then(function(a){return a[0]&&a[0].doc||null}):this.store.get(a)||null},Document.prototype.set=function(a,b){return"object"==typeof a&&(b=a,a=parse_simple(b,this.key)),this.store.set(a,b),this},Document.prototype.searchCache=searchCache,Document.prototype.export=exportDocument,Document.prototype.import=importDocument,apply_async(Document.prototype);